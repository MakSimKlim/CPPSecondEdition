// 230529_1 рекурсия
//
// самый эффективный и быстрый алгоритм сортировки - рекурсивный алгоритм "быстрой сортировки": смысл такой
//
// А - опорный элемент массива, делим на меньшие и большие, если подмассив >= 2, то также делим на подмассивы с опорным элементом и т.д.
// обычно за опорный берется элемент посередине
//
// 1) a[0]...a[N]
// p - опорный элемент
// i и j - индексы левого и правого концов последовательности.
// 2) Двигаем i с шагом 1 по направлению к концу массива
// пока не найдем a[i] >= p
// 3) Аналогично двигаем j с шагом 1 по направлению к началу массива
// пока не найдем a[i] <= p
// 4) Если i <= j, то меняем a[i] и a[j] местами
// 5) повторяем шаг 3) пока i <= j
//
// Пример
// <4> 9  7  6  2  3 <8>
//  4 <9> 7  6  2 <3> 8
//  4  3 <7> 6 <2> 9  8
//  4  3  2 |6| 7  9  8 
// Массив поделён на две части
// Левая - элементы меньше опорного
// Правая - элементы больше опорного
// 
// Реализация алгоритма

#include <iostream>

using namespace std;

int RandInt(int min, int max)
{
	return min + rand() % (max - min) + 1;
}

void FillArray(int ar[], int size)
{
	for (int i = 0; i < size; i++)
	{
		ar[i] = RandInt(1, 1000);
	}
}

void ShowArray(int ar[], int size)
{
	for (int i = 0; i < size; i++)
		cout << ar[i] << " ";
	cout << endl;
}

const int SIZE = 10;

template <typename T>
void QuickSort(T a[], int N)
{
	// a[] - сортируемый массив
	// N - индекс последнего элемента
	int i = 0, j = N;
	// temp - временный элемент для обмена, р - опорный элемент (середина отрезкеа N)
	T temp, p;
	p = a[ N / 2 ]; // N/2 - т.к. p  - середина отрезка N

	do // условие выхода из цикла
	{
		while ( a[i] < p ) i++; // идем к концу массива
		while ( a[j] > p ) j--; // идем к началу массива
		if (i <= j)
		{
			temp = a[i];
			a[i] = a[j];
			a[j] = temp;
			i++; j--;//чтобы не исключать опорный элемент
		}
	} while (i <= j);

	//если еще есть что-то сортировать
	if (j > 0) QuickSort(a, j);
	//если еще есть что-то сортировать
	if (N > i) QuickSort(a + i, N - i);//адрес а сместили на адрес i элемента; N-i - длина массива; опорный элемент - середина N-i

}

int main()
{
	setlocale(LC_ALL, "Rus");


	// создание массива
	int ar[SIZE];
	FillArray(ar, SIZE);
	ShowArray(ar, SIZE);

	// быстрая сортировка
	QuickSort(ar, SIZE - 1);
	cout << "Sorted: " << "\n";
	ShowArray(ar, SIZE);




	return 0;
}