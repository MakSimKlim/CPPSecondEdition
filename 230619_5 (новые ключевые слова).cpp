// 230619_5 (новые ключевые слова)
// 
// AUTO
//
// если используем auto в функции с несколькими точками возврата return, то возникает ошибка в использовании auto, т.к. он 
// берет тип данных до первого return!!!
//
// Auto не может работать с разными типами данных

#include <iostream>
using namespace std;

auto maxF(double a, double b) -> double // AUTO не выполняет вывод типа, а является частью синтаксиса, 
// компилятор делает выводы о типе данных по хвостовому типу -> double
{
	return a < b ? a : b;
}
//=========================================================
// int (*arr)[5] = new int[][5];
int(*myFunc(int arr[][5], int n))[5]
{
return &arr[n];
}
// ниже более понятная запись с хвостовым типом
auto myFunc(int arr[][5], int n) -> int(*)[5]
{
return &arr[n];
}
//=========================================================
// указатель на функцию с хвостовым возвращающим типом
auto myFunc2() -> int(*(*)(int arr[][5], int n))[5]
{
	return myFunc;
}
//=========================================================
auto myFunc3(float a, int b, int c) -> decltype((a+b)/c)
{
	return (a + b) / c;
}
//=========================================================
// вызов функции внутри функции
auto myFunc4(float a, int b, int c, int d) -> decltype(myFunc3(a, b, c) / d)
{
	return myFunc3(a, b, c) / d;
}
//чтобы определить тип данных функции вможно использовать auto и decltype (например при использовании сторонних библиотек) 
// 
//=========================================================
auto modF()// можно использовать  auto как возвращаемый тип функции, но могут возникнуть конфликты, если несколько return!!!
{
	auto a = 20;
	auto b = 10;
	if (a<b)
	{
		return a + 10.5;
	}
	else
	{
		return b + 10.5;
	}
}

double minF(double a, double b)
{
	return a < b ? a : b;
}

int main()
{
	double myVar;
	myVar = 4.2;
	double myVar2 = 4.2;

	// ключевое слово AUTO - позволяет не писать тип данных для переменной, компилятор определяет его автоматически
	// автоматически тип данных переменной становится такой же как у литерала
	// появилось только в последних версиях с++ (версия 14)
	// всегда используется с инициализированными переменными!!!, т.к. иначе не будет знать какой тип использовать

	auto myVar = 4.5;
	auto myVar2 = 5 + 6.4f;
	auto myVarP = &myVar;
	auto myVar3 = minF(myVar, myVar2);
	auto myVar4 = myVar;

	auto muVar4 = modF();

	decltype(myVar) j = myVar; // ключевое слово извлечения типа данных
	// эквивалентно auto j = myVar;
	decltype(myVar) i; // может использоваться с неинициализированными переменными

	auto a1 = 0;
	decltype(a1) a2 = a1;
	typedef decltype(a1) ATYPE;// ATYPE - псевдоним
	ATYPE a3 = 5;

	int y = 10;
	int& r = y;
	auto x = r;// эквивалентно auto x = y
	// с помощью AUTO нельзя сделать ссылку!!!

	int k = 10;
	const int& l = k; // l - константная ссылка
	auto z = l;
	// AUTO игнорирует ссылки

	int a = 10;
	int& ra = a;
	int b = 5;
	decltype(ra) v = b;//decltype в отличие от auto определяет ссылку, и берет тип ссылки
	v = 12;
	cout << b;

	decltype(minF(a, b)) varF = 3; // decltype - расширение типа AUTO? извлекает тип и передает его той переменной, с помощью которой он определяяется



	return 0;

}

