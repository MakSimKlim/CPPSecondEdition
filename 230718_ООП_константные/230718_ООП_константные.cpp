// 230718_ООП_константные

#include <iostream>
#include "Date.h"

using namespace std;

const int s = 3;
const char* w{ "Hello world" };
const int days[s]{ 29,30,31 };
// при создании константного объекта всегда только инициализация при объявлении!!!
// его изменять потом нельзя
// никакие методы от константного объекта вызывать нельзя
// константные методы могут вызываться константой, они помечены (const) и компилятор не заглядывает в их реаализацию
// так помечается константный метод    uint16_t GetDay() const { return day; }
// в методах const ставится после наименования метода!!!
// 
// конструктор и деструктор подразумевает изменение объекта класа, поэтому по своей природе они не могут быть константными
// т.к. объект внутри константного метода не изменяется
// за исключением когда метод константный, т.к. все поля внутри этого метода блокируются для изменений
//
// у каждого нестатического метода есть скрытый параметр this, который подразумевает собой указатель на объект класса от которого этот метод вызывается
// у метода const  указывается в конце, т.к. подразумевается что this становится константным и изменять поля его класса нельзя нельзя
//
// поля класса, которые константы или ссылки не могут получать значения из вне кроме момента инициализации
// они инициализируются только с помощью инициализатора
//
// если метод не изменяет данные, то лучше делать его константным




int main()
{
	const Date birthdate{ 10,10,2000 };
	//cout << birthdate.GetYear(); // никакие методы от константного объекта вызывать нельзя кроме константных методов
	Date GetDay();
	return 0;


}
