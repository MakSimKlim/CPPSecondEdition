// 230713_ООП_дилегирование конструктора
//
// каждый раз, когда вызывается конструктор - создается новый объект класса
// когда перегрузка конструктора - вызывается копия объекта
// правильным выходом является вызов дилегирование конструктора (списки инициализации)
// ограничения: недопустимо производить инициализацию в конструкторе и одновременно делать дилегирование, т.к. появятся неоднозначности
// недопустим также циклическое дилегирование конструктора
// 
// класс - это тип данных, который существует абстракно до создания объекта класса, который уже будет конкретной переменной
//
// ==============================================================================================================================
// 
// статические поля (члены) класса (присущи всему классу в целом)
// создаются при запуске программы до создания класса
// их инициализация производится в глобальной зоне видимости вне класса? но доступны они будут и из самого класса
// 


#include <iostream>
#include "Point.h"
using namespace std;


class User
{
	char* name;
	uint16_t age; // тип данных, который использует предсказуемое кол-во бит на любой архитектуре, тот же int, только конкретного размера 4 байта (16 бит), он не может быть отрицательным
	uint32_t id;  // тип данных, который использует предсказуемое кол-во бит на любой архитектуре, тот же int, только конкретного размера 8 байта (32 бита), он не может быть отрицательным
	// uint8_t - тип данных, который использует предсказуемое кол-во бит на любой архитектуре, тот же int, только конкретного размера 8 бит, он не может быть отрицательным
	// uint64_t - тип данных, который использует предсказуемое кол-во бит на любой архитектуре, тот же int, только конкретного размера 64 бита, он не может быть отрицательным
	// uint - unsigned int - используется для одинаковой работы на ВСЕХ машинах, чтобы не было непредсказуемости

public:
	//======================================================================================
	/*// Вариант записи без дилегирования конструктора
	User() : name{ nullptr }, age{ 0 }, id{ 0 }
	{}

	User(const char* nameP) :
		name{ new char[strlen(nameP) + 1] }, age{ 0 }, id{ 0 }
	{
		memcpy_s(name, strlen(nameP) + 1, nameP, strlen(nameP) + 1);
	}
	User(const char* nameP, uint16_t ageP) :
		name{ new char[strlen(nameP) + 1] }, age{ ageP }, id{ 0 }
	{
		memcpy_s(name, strlen(nameP) + 1, nameP, strlen(nameP) + 1);
	}
	User(const char* nameP, uint16_t ageP, uint32_t idP) :
		name{ new char[strlen(nameP) + 1] }, age{ ageP }, id{ idP }
	{
		memcpy_s(name, strlen(nameP) + 1, nameP, strlen(nameP) + 1);
	}
	~User()
	{
		delete[] name;
	}
	*/
	//======================================================================================
    // вариант записи с дилегированием
	// дилегирование (сначала самый полный конструктор)

	// основной конструктор
	User(const char* nameP, uint16_t ageP, uint32_t idP) :
		name{ nameP ? new char[strlen(nameP) + 1]  : nullptr},
	    age{ageP},
	    id{idP}
	{
		if(name)
		memcpy_s(name, strlen(nameP) + 1, nameP, strlen(nameP) + 1);
		cout << "Create user with full parametres " << endl;
	}

	// конструкторы, дилегирующие соответствующие параметры основному конструктору
	User() : User{ nullptr, 0, 0 } { cout << "Created [empty user]" << endl; }

	User(const char* nameP) : User{ nameP, 0, 0 } { cout << "Create user with name " << nameP << endl; }

	User(const char* nameP, uint16_t ageP) : User{ nameP, ageP, 0 } { cout << "Create user with name " << nameP << " age " << ageP << endl; }

	// метод вывода значений в консоль
	void show() 
	{
		if (name)
			cout << name << ", " << age << " years old, UserID = " << id << endl;
		else
			cout << "[empty user]" << endl;
	}

};

void Users()
{
	User nobody;
	nobody.show();

	User u1{ "Sidor" };
	u1.show();

	User u2{ "Adam", 25 };
	u2.show();

	User u3{ "Admin", 30, 123456 };
	u3.show();



}

int main()
{

	Point p1{ 1, 1 };
	p1.maxX = 100;
	p1.maxY = 100;
	Point p2{ 2, 2 };

	p1.x = 4;
	p1.y = 6;

	Point::maxX = 200;// доступ к статическим переменным класса

	cout << p1.x << " " << p1.y << endl;
	cout << p2.x << " " << p2.y << endl;
	cout << p2.maxX << " " << p2.maxY << endl;

	return 0;



}

