// 230622_1
//
// битовые операции (над битами конкретной переменной), применяются
// когда очень большие вычисления
// или маленькие компьютеры с малым объемом памяти 
// (микроконтроллеры arduino, микроволновки, бортовой компьютер)
// 
// в с++ 6 битовых операторов:
// 1). побитовый сдвиг влево << 
// например: 2 << 1 // 1 - на скольки бит сдвигаем
// 0010 -> 0100 = 4
// например: 2 << 2
// 0010 -> 1000 = 8
// например: 2 << 3
// 0010 -> 0000 = 0
// 
// 2) сдвиг вправо >>
// например: 12 >> 1
// 1100 -> 0110 = 6
// например: 12 >> 2
// 1100 -> 0011 = 3
// например: 12 >> 3
// 1100 -> 0001 = 1
// 
// 3). инверсия (тильда) `
// обращение 0 в 1 и наоборот каждого бита
// 4 = 0100
// `4 = 1011 = 11
// 4 = 0000 0100
// `4 = 1111 1011 = 251
// 
// 4). побитовое И & (true (1) где все 1 и (0) где все 0)
// 5 & 6
// 0101
// 0110
// ====
// 0100 - результат (4)
// 
// 1 & 3 & 7
// 0001
// 0011
// 0111
// ====
// 0001 - результат (1)
// 
// 
//  побитовое ИЛИ | (true (1) если один из 2х операндов равен 1)
// 5 | 6 = 0101 | 0110
// 0101
// 0110
// ====
// 0111 - результат (7)
// 
// 1 | 4 | 6 = 0001 | 0100 | 0110
// 0001
// 0100
// 0110
// ====
// 0111 - результат (7)
// 
// 5). ^ (XOR) - исключающее ИЛИ (True где один из операндов столбика = 1, только один из операндов равен 1, нечетное кол-во единиц)
// 6^3
// 0110
// 0011
// ====
// 0101 - результат (5)
// 
// 1 ^ 3 ^ 7 - (где нечетное кол-во 1)
// 0001
// 0011
// 0111
// ====
// 0101 - результат (5)
// 
// 
// 
// 
// 6). */
// 
// Пример 1:
// unsigned int x; // unsigned - обязательно для побитовой операции
// x = 12;
// x = x >> 3; 
// cout << x; // = 1 результат сдвига
//
// Пример 2:
// unsigned int x, y, z, k;
// x = 5, y = 6;
// k = x | y;
// cout << k << " ";
// k = x & y;
// cout << k << " ";
// x = 1, y = 3, z = 7;
// k = x | y | z;
// cout << k << " ";
// k = x & y & z;
// cout << k << " ";
// x = 6, y = 3;
// k = x ^ y;
// cout << k << " ";
//
// Пример 3:
//
// int y= 02, x = 03, z = 01, k; // запись в восьмеричной системе исчисления
// 
// k = x | y & z; // (приоритеты: сначала вычисляется & потом |) // результат 03
// y = 0000 0010
// z = 0000 0001
// k = 03|00
// cout << k << " ";
// 
// k = x | y & -2; // (приоритеты: сначала вычисляется & потом |) // результат 03
//  y = 0000 0010
// -2 = 1111 1110
//  k = 03 | 00 = 03
// cout << k << " ";
// 
// k = x ^ y & -z; // (приоритеты: сначала вычисляется & потом ^) // результат 01
//  y = 0000 0010
//  z = 0000 0001
// -z = 1111 1111
//  y&-z = 0000 0010
//  x = 0000 0011 // 03
//  x^ = 0000 0001
//  k = 03 ^ 01 = 01
// cout << k << " ";
//
// k = x & y && z;
// (x&y)&&z; // приоритет & затем &&
// x=0000 0011
// y=0000 0010
// r=0000 0010
// 02 && 01 // т.к. с обеих сторон от && больше нуля, то результат екгу
// cout << k << " ";
// 
// x =1, y = -1;
// k = !x | x;
// x=0000 0001
// !true | true
// false = !true = 0
// 00 | 01 // побитовое сравнение с 00 дает тоже самое число, т.е. результат 01
// cout << k << " ";
// 
// k = -x | x; // результат -1
// x=0000 0001 // 01
// -x = 1111 1111
// r = 1111 1111 // результат -1
// cout << k << " ";
// 
// k = x ^ x; // результат 0
// x=0000 0001 // 01
// x=0000 0001 // 01
// r = 0000 0000 // результат 0
// cout << k << " ";
//
// k = x ^ x ^ x; // результат 1
// x = 0000 0001 // 01
// x = 0000 0001 // 01
// x = 0000 0001 // 01
// r = 0000 0001 // результат 1
// cout << k << " ";
//
//
// x << =3;
// x = 0000 0001 // 01
// r = 0000 0010 // 03
// cout << x  << " ";
//
//
// y << =3; // =-8
// y = 1111 1111 -> 1111 1000
// cout << y << " ";
//
// y >> =3; // = -1 или 8191
// cout << y << " ";
// 
// ==========================================================================================
//
// ОБЪЕДИНЕНИЕ (union) - позволяет сильно оптимизировать память
// структура, в  которой можно использовать только один из элементов структуры
//

void unions()
{
	//union
	//{
	//	short comp1;
	//	int comp2;
	//	long long comp3;
	//} myUnion;// сразу присваивается переменная к названию myUnion
	//// если больше не планируется использовать другие имена структуры

	//// вариант объявления Union
	////union Example
	////{
	////  short comp1;
	////  int comp2;
	////  long long comp3;	
	////};
	////Example myUnion;

	//struct
	//{
	//	short comp1;
	//	int comp2;
	//	long long comp3;
	//} myStruct; // сразу присваивается переменная к названию myStruct
	//// если больше не планируется использовать другие имена структуры

	//myStruct = { 11, 'r', 16499 };
	//cout << &myStruct << endl;
	//cout << &myUnion << endl;

	//myUnion.comp1 = 10;
	//cout << myUnion.comp1 << endl; // 10

	//myUnion.comp3 = 222222222;
	//cout << myUnion.comp3 << endl; // 222222222

	//cout << myUnion.comp1 << endl; // -10354
	//// значения меняются, т.к. в UNION числа перезаписываются, т.к. находятся в одном неразделенном пространстве памяти
	//// записывая всё в одну и туже цепочки памяти
	//// в этом отличие UNION от структуры, хотя по строению напоминает структуру
	//// если мы знаем, что не будем использовать одновременно переменные, то можно завести Union
	//// Union позволяет использовать один и тот же участок памяти, а не занимать новую под каждую переменную, 
	//// элементы union записываются поверх друг друга начиная всё время с одного и того же места


};


#include <iostream>
using namespace std;


int main()
{
	// битовые поля - занимают тот размер, который ему укажут через :
	struct statusField
	{
		unsigned int JS:1;// :1 указываем сколлько бит нам нужно под память
		unsigned int PHP:1;
		unsigned int Python:1;
	}state;

	
	state = { 1, 0, 1 };

	cout << &state << endl;// результат 05
	// если задаем структуры меньше 8 бит, то под нее все равно выделяется один байт (8 бит)
	// если значение 14, то компилятор выделит необходимое количество бит, кратное 8, т.е выделится 16


	struct date
	{
		unsigned short weekDay : 3;
		unsigned short monthDay : 6;
		unsigned short month : 5;
		unsigned short year : 16; // 8 - места не хватит результатом будет 198 вместо 1990
	};
	date d = { 1,3,10,1990 };
	cout << &d << endl;
	cout << "Date is: " << d.monthDay << "." << d.month << "." << d.year << endl;

	// сочетание данных внутри структуры
	struct myInfo
	{
		// суммарно 7 бит, поэтому появляется [0] бит перед ними до кратного числа 8
		unsigned char part1 : 2; // битовые поля (под него выделяется указанное кол-во бит после :)
		unsigned char part2 : 3;
		unsigned char part3 : 1;
		unsigned char part4 : 1;
		unsigned char myChar; // обычное поле (под него выделяется 1 байт)
		// правило чередовать битовые и обычные поля в структуре нельзя
		// нужно сначала записать все битовые, потом обычные поля или наоборот
		// иначе появятся неоднозначности
	};
	myInfo user1 = { 3,7,0,1,'\t' };
	// как выглядит структура в памяти:
	// память выделяется с конца
	// byte0 (0) раrt4(1) раrt3(1) раrt2(3) раrt1(2) // т.к. char = 8 байт
	cout << &user1 << endl;
	cout << "Size of info: " << sizeof(user1) << endl;

	return 0;
}

