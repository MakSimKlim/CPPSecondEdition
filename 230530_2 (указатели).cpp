// 230530_2 (указатели)
//
//Виды памяти:
//  
//Статическая - область хранения глобальных и статических переменных (которые создаются заведомо один раз и уничтожаются вместе с программой)
//Например: const int SIZE = 10; - глобальная переменная - в статической памяти
//
//Динамичекая память (память свободного хранения) - программа явным образом запрашивает память
//запрашивает память для элементов, а затем явным образом её освобождает.
//механизм указателей (особый тип переменной, который содержит адрес ячейки памяти для любой другой существующей переменной)
//очень характерная для с++ вещь (очень мало языков используют механизм указателей)
//указатель обращается к ячейкам оперативной памяти
// унарный оператир амперсанд &
// & применяется только к тому, что хранится в памяти (только переменные и элементы массивы), не применяется к выражению, литералам
// указатели имеют тип
// указатель (*) хранит адрес ( *py иду по адресу px и получаю значение переменной x)
// с++ имеет прямой доступ к оперативной памяти через указатели

#include <iostream>
#include <math.h>
using namespace std;

void Poointers()
{
	int x = 10, y;
	cout << &x << "\n"; // адрес ячейки где хранится переменная Х
	//cout << & (x - 1 ); // незаконная запись, т.к. у выражения нет ячейки памяти, т.к. оно вычисляется мгноменно
	//cout << &3; // незаконная запись, т.к. 3 - литерал, а не переменная, и нге хранится в памяти
	int* px; //объявление указателя (* - указывает на первый байт переменной, и знает сколько он ещё захватит, на её тип), он не инициализирован
	//<тип> * <переменная>;

	// эквивалент записи х=у:
	px = &x;// теперь в px хранится адрес х,
	y = *px;//разыменовывание указателя, кладем значение которое хранится в указателле в у
	// указатель может хранить только адрес ячейки
	cout << x << "==" << y << "\n";

	// указатели могут входить в выражения
	y = *px + 1;// y = 11

	// вместо х можно писать разыменованный px
	cout << px << " " << *px << " " << x << "\n";
	cout << sqrt((double)*px) << "\n";
	//*(px + 1);//сдвиг на несколько ячеек


	*px = 5;// разыменованный указатель работает как переменная, на которую он указывает
	cout << x << "\n";

	*px = *px - 4;
	cout << x << "\n";

	int* py;
	py = px;
	cout << py << " " << *py << "\n";
	*py = 99;// указатель (*) хранит адрес ( *py иду по адресу py и получаю значение переменной x)
	// разыменовать ру это запись *ру
	cout << py << " " << *py << " " << *px << " " << x << "\n";

}

void MassivPointers()
{
	// массив некоторое подобие указателя
//любую операцию с индексом массива можно выполнить с помощью указателя
	int a[5] = { 1,2,3,4,5 };
	cout << a << "\n"; // просто выведет адрес
	cout << a[1] << "\n";// будет выведено 2

	int* pa = &a[0]; // указателю присвоен адрес первого элемента массива (это тоже самое, что и адрес массива, т.к. адрес массива всегда равен адресу первого элемента)
	cout << pa << " " << a << "\n";

	int x;
	//следующие две строчки эквивалентны
	x = a[0];
	x = *pa;
	cout << *(pa + 1) << "\n";// эквивалентно записи a[1], индекс 1 - на сколько мы сдвигаемся в памяти (это не количество байт, это зависит от типа указателя)
	cout << *(pa + 10) << "\n";// выведет за границы массива, получится некоторое мусорное число
	// нумерация масивов идет с 0, потому что указываем на сколько сместить указатель
	// a[1] = запись означает сдвиг по указателю от адреса массива а на 1 значение (например для int на 4 байта), 
	//что приведет к значению второго элемента массива, поэтому массивы записываются в такой форме, ведь по сути это указатели


}
// одинаковые записи:
// int ar[]
// int* ar
// сумма элементов массива
int GetArSum(int* ptr, int size)
{
	int sum = 0;
	for (int i = 0; i < size; i++, ptr++)
	{
		sum += *ptr;
		return sum;
	}
}

int main()
{
	const int size = 5;
	int arr[size] = { 33,44,7,8,9 };
	int* ptr = arr;// arr хранит адрес(константный указатель, могут меняться значения, но не меняется адрес на который он указывает)
	for (int i = 0; i < size; i++)
	{
		cout << *(ptr + i) << " ";// эквивалентная запись *(arr+i) или ptr[i]
	}
	cout << "\n";
	*(ptr + 1) = 55; // эквивалентная запись *(arr + 1) = 55 или ptr[1] = 55
	*(ptr + 2) = 12; // эквивалентная запись *(arr + 2) = 12 или ptr[2] = 12
	//отобразим массив с помощью указателей
	for (int i = 0; i < size; i++)
	{
		cout << *(ptr + i) << " ";// эквивалентная запись *(arr+i) или ptr[i]
	}
	cout << "\n";

	cout << "\n";
	cout << "Sum: " << GetArSum(ptr, size);



}
