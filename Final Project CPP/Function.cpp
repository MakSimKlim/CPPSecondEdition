#include <iostream> 
#include <windows.h>                                                 // для Handle и CONSOLE_CURSOR_INFO 
#include <conio.h>                                                   // For _getch
#include <cstdlib>                                                   // для exit()
#include <cstring> 
#include <cstdlib>
#include <ctime>
#include <time.h>
#include <cmath>                                                     // For floor & ceil - округления в большую и меньшую сторону
#include <math.h>
#include <stdio.h>                                                   // For fmod - функция определения остатка от деления double на double

#define timer 200                                                    // глобальная переменная задержки таймера времени
#define rounding1 2;     // глобальная переменная округления дробных чисел до указанного знака после точки (для длин заготовок)
#define rounding2 0;     // глобальная переменная округления дробных чисел до указанного знака после точки (для кол-ва заготовок)

using namespace std;

void ConsoleSettings()                                               // функция настройки параметров консоли
{
    setlocale(LC_ALL, "Rus");
    srand(time(NULL));                                               //рандомайзер
    system("mode con cols=104 lines=20");                            //задание размеров окна консоли
    system("title Курсовой проект - Linear Cutting 2023 V0.2");      //задание описания окна консоли
    system("color 1F");                                              //задание Атрибутов цвета консоли ("1-задний фон А-передний фон")
    
    // директива препроцессора для группировки кода (в данном случае информация по атрибутам цвета консоли)
    #pragma region ColorAtributeInfo
    /*Атрибуты цветов задаются в виде ДВУХ шестнадцатиричных цифр — первая
    задает цвет фона, а вторая определяет цвет переднего плана.Каждая цифра
    может иметь следующие значения :
    0= Черный
    1= Синий     A= Светло - зеленый
    2= Зеленый   B= Светло - голубой
    3= Голубой   C= Светло - красный
    4= Красный   D= Светло - лиловый
    5= Лиловый   E= Светло - желтый
    6= Желтый    F= Ярко - белый
    7= Белый
    8= Серый
    9= Светло - синий
    */
    #pragma endregion 

    // скрытие курсора в консоле
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);               //получение дескриптора окна консоли для настройки различных параметров (текст, курсор, фон и т.д.)
    CONSOLE_CURSOR_INFO cursor = { 100, false };                     //скрываем курсор с консоли: число от 1 до 100 размер курсора в процентах; false\true - видимость
    SetConsoleCursorInfo(hConsole, &cursor);                         //применение заданных параметров курсора

}

void PseudographicsNameProgram()                                    // функция псевдографики заставки программы
{
    //ПСЕВДОГРАФИКА ЗАСТАВКИ
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);              //получение дескриптора окна консоли для настройки различных параметров (текст, курсор, фон и т.д.)

    SetConsoleTextAttribute(hConsole, 1);                           //изменение цвета текста с обращением к дескриптору hConsole
    cout << "     ****************************************************************************************** \n\n\n\n\n\n\n\n\n\n\n $$      $$$$$$  $$  $$  $$$$$   $$$$   $$$$$     $$$$   $$  $$  $$$$$$  $$$$$$  $$$$$$  $$  $$   $$$$ ";
    Sleep(timer);
    system("cls");
    SetConsoleTextAttribute(hConsole, 2);                           //изменение цвета текста с обращением к дескриптору hConsole
    cout << "     *                  Программа экономичного линейного раскроя материалов V0.2              *\n     ****************************************************************************************** \n\n\n\n\n\n\n\n\n $$      $$$$$$  $$  $$  $$$$$   $$$$   $$$$$     $$$$   $$  $$  $$$$$$  $$$$$$  $$$$$$  $$  $$   $$$$ \n $$        $$    $$$ $$  $$     $$  $$  $$  $$   $$  $$  $$  $$    $$      $$      $$    $$$ $$  $$ \n $$        $$    $$ $$$  $$$$   $$$$$$  $$$$$    $$      $$  $$    $$      $$      $$    $$ $$$  $$ $$$ ";
    Sleep(timer);
    system("cls");
    SetConsoleTextAttribute(hConsole, 3);                           //изменение цвета текста с обращением к дескриптору hConsole
    cout << "     ******************************************************************************************\n     *                  Программа экономичного линейного раскроя материалов V0.2              *\n     ****************************************************************************************** \n\n\n\n\n\n\n $$      $$$$$$  $$  $$  $$$$$   $$$$   $$$$$     $$$$   $$  $$  $$$$$$  $$$$$$  $$$$$$  $$  $$   $$$$ \n $$        $$    $$$ $$  $$     $$  $$  $$  $$   $$  $$  $$  $$    $$      $$      $$    $$$ $$  $$ \n $$        $$    $$ $$$  $$$$   $$$$$$  $$$$$    $$      $$  $$    $$      $$      $$    $$ $$$  $$ $$$ \n $$        $$    $$  $$  $$     $$  $$  $$  $$   $$  $$  $$  $$    $$      $$      $$    $$  $$  $$  $$ \n $$$$$$  $$$$$$  $$  $$  $$$$$  $$  $$  $$  $$    $$$$    $$$$     $$      $$    $$$$$$  $$  $$   $$$$ ";
    Sleep(timer);
    SetConsoleTextAttribute(hConsole, 4);                           //изменение цвета текста с обращением к дескриптору hConsole
    system("cls");
    cout << "     ******************************************************************************************\n     *                  Программа экономичного линейного раскроя материалов V0.2              *\n     ****************************************************************************************** \n\n\n\n\n $$      $$$$$$  $$  $$  $$$$$   $$$$   $$$$$     $$$$   $$  $$  $$$$$$  $$$$$$  $$$$$$  $$  $$   $$$$ \n $$        $$    $$$ $$  $$     $$  $$  $$  $$   $$  $$  $$  $$    $$      $$      $$    $$$ $$  $$ \n $$        $$    $$ $$$  $$$$   $$$$$$  $$$$$    $$      $$  $$    $$      $$      $$    $$ $$$  $$ $$$ \n $$        $$    $$  $$  $$     $$  $$  $$  $$   $$  $$  $$  $$    $$      $$      $$    $$  $$  $$  $$ \n $$$$$$  $$$$$$  $$  $$  $$$$$  $$  $$  $$  $$    $$$$    $$$$     $$      $$    $$$$$$  $$  $$   $$$$ ";
    Sleep(timer);
    system("cls");
    SetConsoleTextAttribute(hConsole, 5);                          //изменение цвета текста с обращением к дескриптору hConsole
    cout << "     ******************************************************************************************\n     *                  Программа экономичного линейного раскроя материалов V0.2              *\n     ****************************************************************************************** \n\n\n $$      $$$$$$  $$  $$  $$$$$   $$$$   $$$$$     $$$$   $$  $$  $$$$$$  $$$$$$  $$$$$$  $$  $$   $$$$ \n $$        $$    $$$ $$  $$     $$  $$  $$  $$   $$  $$  $$  $$    $$      $$      $$    $$$ $$  $$ \n $$        $$    $$ $$$  $$$$   $$$$$$  $$$$$    $$      $$  $$    $$      $$      $$    $$ $$$  $$ $$$ \n $$        $$    $$  $$  $$     $$  $$  $$  $$   $$  $$  $$  $$    $$      $$      $$    $$  $$  $$  $$ \n $$$$$$  $$$$$$  $$  $$  $$$$$  $$  $$  $$  $$    $$$$    $$$$     $$      $$    $$$$$$  $$  $$   $$$$ ";
    Sleep(timer);
    system("cls"); 
    SetConsoleTextAttribute(hConsole, 6);                          //изменение цвета текста с обращением к дескриптору hConsole
    cout << "     ******************************************************************************************\n     *                  Программа экономичного линейного раскроя материалов V0.2              *\n     ****************************************************************************************** \n $$      $$$$$$  $$  $$  $$$$$   $$$$   $$$$$     $$$$   $$  $$  $$$$$$  $$$$$$  $$$$$$  $$  $$   $$$$ \n $$        $$    $$$ $$  $$     $$  $$  $$  $$   $$  $$  $$  $$    $$      $$      $$    $$$ $$  $$ \n $$        $$    $$ $$$  $$$$   $$$$$$  $$$$$    $$      $$  $$    $$      $$      $$    $$ $$$  $$ $$$ \n $$        $$    $$  $$  $$     $$  $$  $$  $$   $$  $$  $$  $$    $$      $$      $$    $$  $$  $$  $$ \n $$$$$$  $$$$$$  $$  $$  $$$$$  $$  $$  $$  $$    $$$$    $$$$     $$      $$    $$$$$$  $$  $$   $$$$ ";
    Sleep(timer);
    SetConsoleTextAttribute(hConsole, 7);                          //изменение цвета текста с обращением к дескриптору hConsole

    for (int i = 1; i < 10; i++)                                   // перебор цветов циклом
    {
        system("cls");
        cout << "\n";
        cout << R"(     ******************************************************************************************" 
     *                  Программа экономичного линейного раскроя материалов V0.2              *" 
     ******************************************************************************************" 

 $$      $$$$$$  $$  $$  $$$$$   $$$$   $$$$$     $$$$   $$  $$  $$$$$$  $$$$$$  $$$$$$  $$  $$   $$$$
 $$        $$    $$$ $$  $$     $$  $$  $$  $$   $$  $$  $$  $$    $$      $$      $$    $$$ $$  $$
 $$        $$    $$ $$$  $$$$   $$$$$$  $$$$$    $$      $$  $$    $$      $$      $$    $$ $$$  $$ $$$
 $$        $$    $$  $$  $$     $$  $$  $$  $$   $$  $$  $$  $$    $$      $$      $$    $$  $$  $$  $$
 $$$$$$  $$$$$$  $$  $$  $$$$$  $$  $$  $$  $$    $$$$    $$$$     $$      $$    $$$$$$  $$  $$   $$$$

*** FREE VERSION *** FREE VERSION *** FREE VERSION ** FREE VERSION *** FREE VERSION *** FREE VERSION ***

                                *** ATTENTION! limited functionality *** 
)" << "\n";
        SetConsoleTextAttribute(hConsole, i);                    // изменение цвета текста с обращением к дескриптору hConsole
        Sleep(timer);
    }

    system("color 1F");                                          // задание цвета консоли (1-задний фон; 7-передний фон)

    //Music();

    //Sleep(20 * timer);                                         // задержка заставки

    //system("pause");

    for (int i = 0; i < 60; i++)                                 // для того, чтобы надпись Copyright была внизу консоли на пустом фоне
    {
        cout << "\n";
    }
    cout << "Copyright Климов М.А. 2023\n";                      //flush - принудительный сброс буферов
    cout << R"(Алгоритмы, применяемые в данном ПО являются интеллектуальной собственностью 
разработчика и защищены авторским правом)" << endl << flush;     //flush - принудительный сброс буферов

    //cout << '\a';                                             // звук

    system("pause");

    system("cls");
}

void EndOfProgram()
{
    cout << "Спасибо за внимание" << endl;
}

int StartMenuOfProgram(int menuBottom)                                   //функция стартового меню
{
    switch (menuBottom)
    {
    case 1:
        cout << "\n\n\n                                        <<  ЗАПОЛНЕНИЕ ДАННЫХ >>\n\n                                                 ПОМОЩЬ\n\n                                           КУПИТЬ ПОЛНУЮ ВЕРСИЮ\n\n                                                 ВЫХОД";
        break;
    case 2:
        cout << "\n\n\n                                            ЗАПОЛНЕНИЕ ДАННЫХ\n\n                                             <<  ПОМОЩЬ  >>\n\n                                           КУПИТЬ ПОЛНУЮ ВЕРСИЮ\n\n                                                 ВЫХОД";
        break;
    case 3:
        cout << "\n\n\n                                            ЗАПОЛНЕНИЕ ДАННЫХ\n\n                                                 ПОМОЩЬ\n\n                                        << КУПИТЬ ПОЛНУЮ ВЕРСИЮ >>\n\n                                                 ВЫХОД";
        break;
    case 4:
        cout << "\n\n\n                                            ЗАПОЛНЕНИЕ ДАННЫХ\n\n                                                 ПОМОЩЬ\n\n                                           КУПИТЬ ПОЛНУЮ ВЕРСИЮ\n\n                                            <<   ВЫХОД   >>";
        break;
    }

    int choice = _getch();                               //получить значение нажатой клавиши

    if (choice == 224)                                   //если была нажата стрелка
    {
        choice = _getch();                               //то определить какая именно
    }
    if (choice == 72)                                    //если стрелка вверх
    {
        if (menuBottom != 1)
        {
            StartMenuOfProgram(menuBottom - 1);
        }
        else
        {
            StartMenuOfProgram(4);
        }
    }
    if (choice == 80)                                   //если стрелка вниз
    {
        if (menuBottom != 4)
        {
            StartMenuOfProgram(menuBottom + 1);
        }
        else
        {
            StartMenuOfProgram(1);
        }
    }
    if (choice == 27)                                  //если Escape
    {
        StartMenuOfProgram(1);
    }

    if (choice == 13 || choice == 32)                 // 13-enter, 32 - пробел
    {
        if (menuBottom == 1)
        {
            ChoiceInput(1);
        }
        if (menuBottom == 2)
        {
            Help(0);
        }
        if (menuBottom == 3)
        {
            system("cls");
            cout << "Пункт меню находится в стадии разработки" << "\n";
            cout << "\n\n\n                                   <<  БЕСПЛАТНАЯ ДЕМО ВЕРСИЯ >>\n\n                                        КУПИТЬ ПОЛНУЮ ВЕРСИЮ\n\n";
            system("pause");
            StartMenuOfProgram(1);
            //BuyFullVersion();
        }
        if (menuBottom == 4)
        {
            system("cls");
            _exit(0);
            //return 0;
        }
    }
    return menuBottom;

}

int ChoiceInput(int menuBottom) //функция меню ввода данных
{
    system("cls");                                     //очищает экран конслоли

    switch (menuBottom)
    {
    case 1:
        cout << "\n\n\n\n\n                                <<  РАНДОМНОЕ ЗАПОЛНЕНИЕ ДАННЫХ (ТЕСТ)  >>\n\n                                        ЗАПОЛНЕНИЕ ДАННЫХ ВРУЧНУЮ \n\n                                        ЗАПОЛНЕНИЕ ДАННЫХ ИЗ ФАЙЛА";
        break;
    case 2:
        cout << "\n\n\n\n\n                                    РАНДОМНОЕ ЗАПОЛНЕНИЕ ДАННЫХ (ТЕСТ)\n\n                                    <<  ЗАПОЛНЕНИЕ ДАННЫХ ВРУЧНУЮ  >> \n\n                                        ЗАПОЛНЕНИЕ ДАННЫХ ИЗ ФАЙЛА";
        break;
    case 3:
        cout << "\n\n\n\n\n                                    РАНДОМНОЕ ЗАПОЛНЕНИЕ ДАННЫХ (ТЕСТ)\n\n                                        ЗАПОЛНЕНИЕ ДАННЫХ ВРУЧНУЮ \n\n                                    <<  ЗАПОЛНЕНИЕ ДАННЫХ ИЗ ФАЙЛА  >>";
        break;
    }

    int choice = _getch();                            //получить значение нажатой клавиши

    if (choice == 224)                                //если была нажата стрелка
    {
        choice = _getch();                            //то определить какая именно
    }

    if (choice == 72)                                 //если стрелка вверх
    {
        if (menuBottom != 1)
        {
            ChoiceInput(menuBottom - 1);
        }
        else
        {
            ChoiceInput(3);
        }
    }
    if (choice == 80)                                //если стрелка вниз
    {
        if (menuBottom != 3)
        {
            ChoiceInput(menuBottom + 1);
        }
        else
        {
            ChoiceInput(1);
        }
    }

    if (choice == 27)                               //если Escape
    {
        StartMenuOfProgram(1);
    }

    if (choice == 13 || choice == 32)              // 13-enter, 32 - пробел
    {
        if (menuBottom == 1)
        {
            StartArrayRand(0);
        }
        if (menuBottom == 2)
        {
            StartArrayHand(0);
        }
        if (menuBottom == 3)
        {
            StartArrayFile(0);
        }
    }

    return menuBottom;
}

int StartArrayRand(int lines) // функция создания рандомного двумерного динамического массива в котором первый столбец - длины отрезков, второй - их кол-во
{
    system("cls");                                      // очищает экран конслоли

    int size = 2;                                       // количество столбцов массива (длина заготовок и количество)

    ofstream fout("input.txt");                        // это специальный тип, с помощью которого можно только записывать в файл данные.

    cout << "Введите количество видов отрезков по проекту: " << "\n";
    cin >> lines;
    fout << lines << "\n";                             //Вывод в файл input.txt значение количества видов однотипных отрезков

    double** arr;                                      // Для доступа к двумерному массиву объявляется переменная arr типа указатель на указатель на тип 
    // (в данном случае это указатель на указатель на double).
// создание массива
    arr = new double* [lines];                         // массив указателей.Переменная инициализируется оператором new, который выделяет память для массива указателей на double
    for (int i = 0; i < lines; i++)
    {
        arr[i] = new double[size];                     // инициализация указателей. В цикле каждый элемент массива указателей инициализируется оператором new, 
        // который выделяет память для массива типа double.
    }
    // работа с массивом (заполнение)
    for (int j = 0; j < lines; j++)
    {
        for (int i = 0; i < size; i++)
        {
            if (i == 0)                                                            // заполнение первого столбца массива рандомными дробными числами (длины отрезков в метрах)
            {
                //arr[j][i] = (double)(rand()) / RAND_MAX * (11.7 - 0.10) + 0.10;  // генерирует дробные числа от  0,1 до Размера заводской заготовки (хлыста) - например 11.7
                arr[j][i] = 10 + rand() % (11700 - 10);                            // генерирует дробные числа от  10 до 11700
                fout << fixed;                                                     // округление до нужного количества знаков
                fout.precision(rounding1);                                         // precision делает округление по правилам математики (кол-во знаков после точки).
                cout << fixed;                                                     // округление до нужного количества знаков
                cout.precision(rounding1);                                         // precision делает округление по правилам математики (кол-во знаков после точки).
            }
            else                                                                   // заполнение второго столбца массива рандомными целыми числами
            {
                arr[j][i] = 1 + rand() % (1000 - 1);                               // генерирует дробные числа от  1 до 1000
                fout << fixed;                                                     // округление до нужного количества знаков
                fout.precision(rounding2);                                         // precision делает округление по правилам математики (кол-во знаков после точки).
                cout << fixed;                                                     // округление до нужного количества знаков
                cout.precision(rounding2);                                         // precision делает округление по правилам математики (кол-во знаков после точки).
            }
            fout << arr[j][i] << " ";                                              // вывод массива в файл
            cout << arr[j][i] << " ";                                              // вывод массива на экран
        }
        fout << "\n";
        cout << "\n";
    }

    cout << R"(Внимание! 
 В тестовом режиме необходимо ввести размер сырьевых заводских заготовок (хлыстов) не менее 11700 мм)" << "\n";

    system("pause");

    MainAlgorytm(lines, size, arr);                                               // функция главного алгоритма

    // очистка памяти, выделенной под массив
    for (int i = 0; i < lines; i++)
    {
        delete[] arr[i];                                                         // Освобождение памяти происходит строго в обратном порядке: 
        // сначала уничтожаются массивы значений типа int, а затем уничтожается массив указателей.
    }
    fout.close();                                                                // закрыть файл вывода

    system("cls");

    cout << "Результаты расчёта смотрите в файле 'output(sorted).txt' в корне программы\n\n\n";

    return lines;
}

int StartArrayHand(int lines) // функция ручного создания двумерного динамического массива в котором первый столбец - длины отрезков, второй - их кол-во
{
    system("cls");                                                               // очищает экран конслоли

    int size = 2;                                                                // количество столбцов массива (длина заготовок и количество)
    ofstream fout("input.txt");                                                 // это специальный тип, с помощью которого можно только записывать в файл данные.

    cout << "Введите количество видов отрезков по проекту: " << "\n";
    cin >> lines;
    fout << lines << "\n";                                                      //Вывод в файл input.txt значение количества видов однотипных отрезков

    system("cls");                                                               // очищает экран конслоли

    double** arr;                                                                // Для доступа к двумерному массиву объявляется переменная arr типа указатель на указатель на тип 
    // (в данном случае это указатель на указатель на double).
// создание массива
    arr = new double* [lines];                                                   // массив указателей.Переменная инициализируется оператором new, который выделяет память для массива указателей на double
    for (int i = 0; i < lines; i++)
    {
        arr[i] = new double[size];                                               // инициализация указателей. В цикле каждый элемент массива указателей инициализируется оператором new, 
        // который выделяет память для массива типа double.
    }

    // работа с массивом (заполнение)
    cout << "Заполните данные для каждого вида отрезков:" << "\n";

    for (int j = 0; j < lines; j++)
    {
        for (int i = 0; i < size; i++)
        {
            if (i == 0)                                                         // заполнение первого столбца массива рандомными дробными числами (длины отрезков в метрах)
            {
                cout << "Введите длину однотипных отрезков в миллиметрах:" << "\n";
                cin >> arr[j][i];
            }
            else                                                                // заполнение второго столбца массива рандомными целыми числами
            {
                cout << "Введите количество однотипных отрезков в штуках:" << "\n";
                cin >> arr[j][i];
            }
        }
    }

    // работа с массивом (вывод на экран)

    system("cls");                                                            // очищает экран конслоли

    for (int j = 0; j < lines; j++)
    {
        for (int i = 0; i < size; i++)
        {
            if (i == 0)                                                       // заполнение первого столбца массива рандомными дробными числами (длины отрезков в метрах)
            {
                fout << fixed;                                                // округление до нужного количества знаков
                fout.precision(rounding1);                                    // precision делает округление по правилам математики (кол-во знаков после точки).
                cout << fixed;                                                // округление до нужного количества знаков
                cout.precision(rounding1);                                    // precision делает округление по правилам математики (кол-во знаков после точки).
            }
            else                                                              // заполнение второго столбца массива рандомными целыми числами
            {
                fout << fixed;                                                // округление до нужного количества знаков
                fout.precision(rounding2);                                    // precision делает округление по правилам математики (кол-во знаков после точки).
                cout << fixed;                                                // округление до нужного количества знаков
                cout.precision(rounding2);                                    // precision делает округление по правилам математики (кол-во знаков после точки).
            }
            fout << arr[j][i] << " ";                                         // вывод массива в файл
            cout << arr[j][i] << " ";                                         // вывод массива на экран
        }
        fout << "\n";
        cout << "\n";
    }

    cout << R"(Внимание! 
Необходимо ввести размер сырьевых заводских заготовок (хлыстов) 
не менее размеров однотипных отрезков мм)" << "\n";

    system("pause");


    MainAlgorytm(lines, size, arr);                                          // функция главного алгоритма

    // очистка памяти, выделенной под массив
    for (int i = 0; i < lines; i++)
    {
        delete[] arr[i];                                                     // Освобождение памяти происходит строго в обратном порядке: 
        // сначала уничтожаются массивы значений типа int, 
        // а затем уничтожается массив указателей.
    }

    fout.close();                                                            // закрыть файл вывода

    system("cls");

    cout << "Результаты расчёта смотрите в файле 'output(sorted).txt' в корне программы\n\n\n";


    return lines;
}

int StartArrayFile(int lines) // функция создания двумерного динамического массива из файла в котором первый столбец - длины отрезков, второй - их кол-во
{
    system("cls");                                                           // очищает экран конслоли

    int size = 2;                                                            // количество столбцов массива (длина заготовок и количество)

    //ifstream fin("D:/Шаг в будущее/БВ211/MyProjectCPP/LinearCuttingV0.1/LinearCuttingV0.1/input.txt");// это специальный тип, с помощью которого можно только считывать из файла данные.
    fstream fin("input.txt");                                             // это специальный тип, с помощью которого можно только считывать из файла данные.
    //ofstream fout("output.txt");                                             // это специальный тип, с помощью которого можно только записывать в файл данные.

    fin >> lines;                                                            // "Количество видов отрезков

    double** arr;                                                            // Для доступа к двумерному массиву объявляется переменная arr типа указатель на указатель на тип 
    // (в данном случае это указатель на указатель на double).
    // создание массива
    arr = new double* [lines];                                               // массив указателей.Переменная инициализируется оператором new, который выделяет память для массива указателей на double
    for (int i = 0; i < lines; i++)
    {
        arr[i] = new double[size];                                          // инициализация указателей. В цикле каждый элемент массива указателей инициализируется оператором new, 
        // который выделяет память для массива типа double.
    }

    // работа с массивом (заполнение)
    for (int j = 0; j < lines; j++)
    {
        for (int i = 0; i < size; i++)
        {
            fin >> arr[j][i];                                              // ввод значений из файла
        }

        cout << "\n";
    }

    // работа с массивом (вывод на экран)

    system("cls");                                     // очищает экран конслоли

    for (int j = 0; j < lines; j++)
    {
        for (int i = 0; i < size; i++)
        {
            if (i == 0)                               // заполнение первого столбца массива рандомными дробными числами (длины отрезков в метрах)
            {
                //fout << fixed;                        // округление до нужного количества знаков
                //fout.precision(rounding1);            // precision делает округление по правилам математики (кол-во знаков после точки).
                cout << fixed;                        // округление до нужного количества знаков
                cout.precision(rounding1);            // precision делает округление по правилам математики (кол-во знаков после точки).
            }
            else                                      // заполнение второго столбца массива рандомными целыми числами
            {
                //fout << fixed;                        // округление до нужного количества знаков
                //fout.precision(rounding2);            // precision делает округление по правилам математики (кол-во знаков после точки).
                cout << fixed;                        // округление до нужного количества знаков
                cout.precision(rounding2);            // precision делает округление по правилам математики (кол-во знаков после точки).
            }
            //fout << arr[j][i] << " ";                 // вывод массива в файл
            cout << arr[j][i] << " ";                 // вывод массива на экран
        }
        //fout << "\n";
        cout << "\n";
    }

    cout << R"(Внимание! 
Необходимо ввести размер сырьевых заводских заготовок (хлыстов) 
не менее размеров однотипных отрезков мм)" << "\n";

    system("pause");


    MainAlgorytm(lines, size, arr);                   // функция главного алгоритма

    //очистка памяти, выделенной под массив
    for (int i = 0; i < lines; i++)
    {
        delete[] arr[i];                              // Освобождение памяти происходит строго в обратном порядке: 
        // сначала уничтожаются массивы значений типа int, а затем уничтожается массив указателей.
    }

    fin.close();                                      // закрыть файл ввода
    //fout.close();                                     // закрыть файл вывода

    system("cls");

    cout << "Результаты расчёта смотрите в файле 'output(sorted).txt' в корне программы\n\n\n";


    return lines;
}

int MainAlgorytm(int lines, int size, double** arr)
{
    ofstream fout("output(sorted).txt");              // это специальный тип, с помощью которого можно только записывать в файл данные.

    for (int i = 1; i < lines; i++)                   // Массив, сортированный по уменьшению методом пузырька по первому столбцу
    {
        for (int k = 0; k < lines - i; k++)
        {
            if (arr[k][0] < arr[k + 1][0])
            {
                swap(arr[k], arr[k + 1]);
            }
        }
    }

    //вывод на экран и в файл
    cout << "Массив после сортировки:" << "\n";
    for (int j = 0; j < lines; j++)
    {
        for (int i = 0; i < size; i++)
        {
            if (i == 0)                               // заполнение первого столбца массива рандомными дробными числами (длины отрезков в метрах)
            {
                fout << fixed;                        // округление до нужного количества знаков
                fout.precision(rounding1);            // precision делает округление по правилам математики (кол-во знаков после точки).
                cout << fixed;                        // округление до нужного количества знаков
                cout.precision(rounding1);            // precision делает округление по правилам математики (кол-во знаков после точки).
            }
            else                                      // заполнение второго столбца массива рандомными целыми числами
            {
                fout << fixed;                        // округление до нужного количества знаков
                fout.precision(rounding2);            // precision делает округление по правилам математики (кол-во знаков после точки).
                cout << fixed;                        // округление до нужного количества знаков
                cout.precision(rounding2);            // precision делает округление по правилам математики (кол-во знаков после точки).
            }
            fout << arr[j][i] << " ";                 // вывод массива в файл
            cout << arr[j][i] << " ";                 // вывод массива на экран
        }
        fout << "\n";
        cout << "\n";
    }
    //=========================================================================================================================================================
    // блок расчета основного алгоритма (может модернизироваться)

    double whipLength = 0;                           // длина заводской заготовки (хлыста)
    double cutLength = 0;                            // длины отрезков в массиве
    double cutQuantity = 0;                          // количество заготовок в массиве
    double counterCut = 0;                           // счетчик возможного количества отрезков в одном заводском хлысте
    double whipQuantity = 0;                         // необходимое количество хлыстов для одного вида отрезков
    double businessLength = 0;                       // длина деловых отрезков для одного вида
    double sumWhipQuantity = 0;                      // сумма необходимого количества хлыстов
    double sumBusinessLength = 0;                    // сумма длин деловых отрезков
    double sumWhipLength = 0;                        // сумма длин необходимого количества хлыстов для одного вида отрезков
    double sumWhipLengthTotal = 0;                   // сумма длин необходимого количества хлыстов общая
    double sumTrimLength = 0;                        // сумма длин обрези (остатков от вычета отрезков из заводской заготовки)
    double sumTrimLengthTotal = 0;                   // сумма длин обрези (остатков от вычета отрезков из заводской заготовки) общая 
    int counterLines = 0;                            // счетчик строк массива


    cout << "Введите длину сырьевой заводской заготовки (хлыста) в миллиметрах: " << "\n";
    cin >> whipLength;
    cout << "\n";

    fout << "Расчёт необходимого количества однотипных сырьевых заводских заготовок длиной " << whipLength << " мм\n\n";
    cout << "Расчёт необходимого количества однотипных сырьевых заводских заготовок длиной " << whipLength << " мм\n\n";

    while (counterLines < lines)
    {
        for (int i = 0; i < lines; i++)
        {
            counterLines++;                                     // счетчик строк массива для цикла while

            cutLength = arr[i][0];                              // длины отрезков в массиве
            fout << fixed;                                      // округление до нужного количества знаков
            fout.precision(rounding1);                          // precision делает округление по правилам математики (кол-во знаков после точки).
            fout << "\n№" << i + 1 << " Расчёт сырья для деловых отрезков одного вида проектной длины " << cutLength << " мм: " << "\n";
            cutQuantity = arr[i][1];                            // количество заготовок в массиве
            fout << fixed;                                      // округление до нужного количества знаков
            fout.precision(rounding2);                          // precision делает округление по правилам математики (кол-во знаков после точки).
            fout << "Необходимое количество деловых отрезков по проекту, шт: " << cutQuantity << "\n";
            counterCut = floor(whipLength / cutLength);         // счетчик возможного количества отрезков в одном заводском хлысте
            fout << "Теоретически возможное количество отрезков с одного заводского хлыста, шт: " << floor(counterCut) << "\n";
            // floor - округление в сторону меньшего числа  
            whipQuantity = ceil(cutQuantity / counterCut);      // необходимое количество хлыстов 
            fout << "Рассчитанное количество заводских хлыстов, шт: " << ceil(whipQuantity) << "\n";
            // ceil - округление в сторону большего числа  
            businessLength = cutLength * cutQuantity;           // длина деловых отрезков
            fout << fixed;                                      // округление до нужного количества знаков
            fout.precision(rounding1);                          // precision делает округление по правилам математики (кол-во знаков после точки).
            fout << "Cумма длин деловых отрезков, мм: " << businessLength << "\n";
            sumWhipLength = whipLength * whipQuantity;          // сумма длин необходимого количества хлыстов
            fout << fixed;                                      // округление до нужного количества знаков
            fout.precision(rounding1);                          // precision делает округление по правилам математики (кол-во знаков после точки).
            fout << "Cумма длин необходимого количества заводских хлыстов, мм: " << sumWhipLength << "\n";
            sumTrimLength = sumWhipLength - businessLength;     // сумма длин обрези (остатков от вычета отрезков из заводской заготовки)
            fout << fixed;                                      // округление до нужного количества знаков
            fout.precision(rounding1);                          // precision делает округление по правилам математики (кол-во знаков после точки).
            fout << "Cумма длин обрези (остатки за вычетом деловых отрезков), мм: " << sumTrimLength << "\n\n";

            sumWhipQuantity += whipQuantity;
            sumBusinessLength += businessLength;
            sumWhipLengthTotal += sumWhipLength;
            sumTrimLengthTotal += sumTrimLength;
        }
    }

    fout << fixed;                                             // округление до нужного количества знаков
    fout.precision(rounding2);                                 // precision делает округление по правилам математики (кол-во знаков после точки).
    fout << "\nИтого сумма необходимого количества заводских хлыстов: " << sumWhipQuantity << " штук" << "\n";
    fout << fixed;                                             // округление до нужного количества знаков
    fout.precision(rounding1);                                 // precision делает округление по правилам математики (кол-во знаков после точки).
    fout << "Итого сумма длин деловых отрезков по проекту: " << sumBusinessLength / 1000 << " метров" << "\n";
    fout << fixed;                                             // округление до нужного количества знаков
    fout.precision(rounding1);                                 // precision делает округление по правилам математики (кол-во знаков после точки).
    fout << "Итого сумма длин необходимого количества хлыстов: " << sumWhipLengthTotal / 1000 << " метров" << "\n";
    fout << fixed;                                             // округление до нужного количества знаков
    fout.precision(rounding1);                                 // precision делает округление по правилам математики (кол-во знаков после точки).
    fout << "Итого сумма длин обрези: " << sumTrimLengthTotal / 1000 << " метров" << "\n\n";

    fout << "Итого обрезь в % от суммы деловых отрезков по проекту: " << ((sumWhipLengthTotal / sumBusinessLength) - 1) * 100 << " %" << "\n\n";


    //=========================================================================================================================================================

    fout.close();                                              // закрыть файл вывода

    return lines;
}

void Help(int switcher)                                           //функция меню ПОМОЩЬ
{
    system("cls");
    cout << "\nПРОКРУТКА: СТРЕЛКИ ВВЕРХ/ВНИЗ | ВЕРНУТЬСЯ: ESCAPE\n";
    char arr[1800] = { "                УПРАВЛЕНИЕ В МЕНЮ                 Передвигаться по пунктам – СТРЕЛКИ ВВЕРХ/ВНИЗ     Выбрать пункт – ПРОБЕЛ или ENTER                  Вернуться в предыдущее меню – ESCAPE                                   БРИФИНГ                           Программа предназначена для оптимизации раскроя профиля и других длинномерных материалов (брус, бревно, труба, подоконник). В бесплатной версии используется 'глупый' алгоритм, не учитывающий использование обрези в дело. В коммерческой версии использован алгоритм 'плотной укладки', то есть взятое изделие укладывается на остаток заготовки, на который она помещается.Если никуда не помещается, берется новая заготовка. Задачей оптимизации является нахождение последовательности изделий, при которой будет использовано меньше заготовок и будет больше длина деловых обрезков.                                           АВТОРСТВО                     Klimov Maxim – AUTHOR                             Obuhov Daniil – COACH                             2023" };
    for (int i = 0, buf = switcher; i < 17; i++)                  // меню со скроллингом текста
    {
        for (int j = buf * 50; j < buf * 50 + 50; j++)
            cout << arr[j];
        if (i != 16)
            cout << "\n";
        buf++;
    }
    int controller = _getch();                                    //получить значение нажатой клавиши
    if (controller == 224)                                        //если была нажата стрелка
        controller = _getch();                                    //то определить какая именно
    if (controller == 72)                                         //если стрелка вверх
        if (switcher > 0)
            Help(switcher - 1);
        else
            Help(0);
    if (controller == 80)                                        //если стрелка вниз
        if (switcher < 22)
            Help(switcher + 1);
        else
            Help(22);
    if (controller == 27)                                        //если Escape
        StartMenu(1);
}

void MenuProgramClassic()                                           // неиспользуемое меню

{
    int choice = 0;                                                 //  переменная выбора значения для меню
    cout << R"(
               Выберите пункт меню:

               1 - выбрать файл с незашифрованным файлом
               2 - записать в файл зашифрованный текст
               3 - открыть файл с зашифрованным текстом
               4 - открыть файл с зашифрованным текстом и расшифровать его
               5 - выход)" << endl;

    cin >> choice;

    while (choice < 1 || choice > 5) // проверка валидности выбора значения
    {

        cout << "Введено неверное значение!" << endl;
        cout << "Выберите пункт меню ещё раз: " << endl;
        cin >> choice;
        cout << "\033[9;1H" << endl; // эскейп последовательность для затирания части экрана
    }


    switch (choice)
    {
    case 1:
        system("cls");
        cout << "выбран пункт меню номер 1" << endl;
        system("pause");
        break;
    case 2:
        system("cls");
        cout << "выбран пункт меню номер 2" << endl;
        system("pause");
        break;
    case 3:
        system("cls");
        cout << "выбран пункт меню номер 3" << endl;
        system("pause");
        break;
    case 4:
        system("cls");
        cout << "выбран пункт меню номер 4" << endl;
        system("pause");
        break;
    default:
        system("cls");
        EndOfProgram();
        exit(0); // выход из консоли
    }

}